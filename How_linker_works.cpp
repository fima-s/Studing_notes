Этапы Компиляции

В целом этапы компиляции можно разделить на 2 этапа: Трансляцию и линковку.
Первый этап иногда еще называют компиляцией.

Трансляция

На данном этапе транслятор (это часть компилятора, которая отвечает на конвертацию 
человекочитаемого исходника в бинарный вид) парсит поданный на вход файл с программой
, проверяет базовый синтаксис и транслирует файл в бинарный вид.
На выходе мы получаем *.o или *.obj файл, в котором содержится бинарный вид 
компилируемого иходника. Файл после этапа трансляции мы не можем запутсить, потому 
что в таком виде (т.е. после трансляции) в файле не определны переходы между вызовами
функции, то есть банально файл не знает какие функции вызывать.

Если написать простой hello world в С++

#include <iostream>
#include <string>

int main()
{
        std::string cmd = "Hello world";
        std::cout << cmd << std::endl;

        return 0;
}

Затем мы скомпилируем этот код, но не дальше этапа трансляции, то есть

gcc -c main.o main.c
//g++: warning: main.o: linker input file unused because linking not done

Дальше посмотрим на содерживоме объектного файла с помощью objdump -d

$ objdump -S main.o | less

0000000000000000 <main>:
   0:   f3 0f 1e fa             endbr64 
   4:   55                      push   %rbp
   5:   48 89 e5                mov    %rsp,%rbp
   8:   53                      push   %rbx
   9:   48 83 ec 48             sub    $0x48,%rsp
   d:   64 48 8b 04 25 28 00    mov    %fs:0x28,%rax
  14:   00 00 
  16:   48 89 45 e8             mov    %rax,-0x18(%rbp)
  1a:   31 c0                   xor    %eax,%eax
  1c:   48 8d 45 bf             lea    -0x41(%rbp),%rax
  20:   48 89 c7                mov    %rax,%rdi
  23:   e8 00 00 00 00          call   28 <main+0x28>
  28:   48 8d 55 bf             lea    -0x41(%rbp),%rdx
  2c:   48 8d 45 c0             lea    -0x40(%rbp),%rax
  30:   48 8d 0d 00 00 00 00    lea    0x0(%rip),%rcx        # 37 <main+0x37>
  37:   48 89 ce                mov    %rcx,%rsi
  3a:   48 89 c7                mov    %rax,%rdi
  3d:   e8 00 00 00 00          call   42 <main+0x42>
  42:   48 8d 45 bf             lea    -0x41(%rbp),%rax
  46:   48 89 c7                mov    %rax,%rdi
  49:   e8 00 00 00 00          call   4e <main+0x4e>

Здесь мы видим нашу функцию main которая отранслирована в asm вид.
И здесь видно, что любой из 2 х представленных call идет по нулевому смещению.
так же мы видим, что будет прыжок <main+0x37> из строчки 30, то есть на следуюущю
строчку, это выглядит как заглушка, потому что у нас нету конечного адреса.

Линковка

После этапа трансляции натсупает тап линковки. Это момент, когда слудующая
часть копилятора по названием линковщик, берет отранслированный объектный файл и
вычилсяет куда должны преходить вызовы в этом файле, буквально, добавляет
адреса функций, который должны будут вызваны в наш объектный файл.

$ g++ -o main main.o

$ objdump -D main | less

0000000000002429 <main>:
    2429:       f3 0f 1e fa             endbr64
    242d:       55                      push   %rbp
    242e:       48 89 e5                mov    %rsp,%rbp
    2431:       53                      push   %rbx
    2432:       48 83 ec 48             sub    $0x48,%rsp
    2436:       64 48 8b 04 25 28 00    mov    %fs:0x28,%rax
    243d:       00 00
    243f:       48 89 45 e8             mov    %rax,-0x18(%rbp)
    2443:       31 c0                   xor    %eax,%eax
    2445:       48 8d 45 bf             lea    -0x41(%rbp),%rax
    2449:       48 89 c7                mov    %rax,%rdi
    244c:       e8 bf fe ff ff          call   2310 <_ZNSaIcEC1Ev@plt>
    2451:       48 8d 55 bf             lea    -0x41(%rbp),%rdx
    2455:       48 8d 45 c0             lea    -0x40(%rbp),%rax
    2459:       48 8d 0d a8 0b 00 00    lea    0xba8(%rip),%rcx        # 3008 <_IO_stdin_used+0x8>
    2460:       48 89 ce                mov    %rcx,%rsi
    2463:       48 89 c7                mov    %rax,%rdi
    2466:       e8 ff 01 00 00          call   266a <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC1IS3_EEPKcRKS3_>
    246b:       48 8d 45 bf             lea    -0x41(%rbp),%rax
    246f:       48 89 c7                mov    %rax,%rdi
    2472:       e8 09 fe ff ff          call   2280 <_ZNSaIcED1Ev@plt>

Как мы видимо, что у наших вызовов функций появился адрес, теперь мы не переходим
в 00 00 00 00. Линковщик предоставил нашему объектному файлу адреса для вызова функций.

// ====================================================================

Shared && Dynamic lib

Статические библиотеки

Статическая означает, что во время линковки библиотека оказывается жестко вшита
внутрь бинарника. По сути, статическая библиотека является архивом с объектными
файлами, который содержат реализацию фукнций из хедера.
таким образом, когда мы собираем стат библиотеку, то вместо вызова линковщика после
трансляции мы собираем все хедеры в один архив и предоставляем их конечному пользователяю
как библиотку.
Пусть у нас есть 2 хедера с соответсвующими cpp файлами, соберем стат библиотеку

$ cat bye.h  
#ifndef BYE_H
#define BYE_H

void print_bye(void);

#endif

//---

$ cat bye.cpp 
#include "bye.h"

#include <iostream>

void print_bye()
{
	std::cout << "Bye world!" << std::endl;
}

//---

$ cat hello.h 
#ifndef PRINT_H
#define PRINT_H

void print_hello();

#endif

//---

$ cat hello.cpp 
#include "hello.h"

#include <iostream>

void print_hello()
{
	std::cout << "Hello world /n";
}


Собираем хедеры, gcc -c hello.c bye.c. Получаем два объектных файла. Дальше их нужно
собрать с помощью ar.
Здесь очень важен нейминг - есть обзая договоренность, что имена библиотек должны 
начинаться с lib. Линковщик будет искать файл, который начинается именно с lib.
Создадим библиотку print с названием файла libprint.a

$ ar rc libprint.a hello.o bye.o

Дальше нам нужно добавить индекс символов к библиотеке, это нужно, 
чтобы линковщик мог понять, какие переменные определены, а какие нет.
большинстве случаев ar добавляет такой индекс сам, но есть ситуации, когда он этого не делает. 
Поэтому хорошим тоном считается добавлять его руками

ranlib libprint.a

Таким образом мы получили статическую библиотеку, которая при линковке окажется буквально 
внутри бинарника.
Посмотрим, как это выглядит.

$ g++ main.cpp -L. -lprint -o main

$ objdump -d main | less

00000000000011a9 <main>:
    11a9:       f3 0f 1e fa             endbr64 
    11ad:       55                      push   %rbp
    11ae:       48 89 e5                mov    %rsp,%rbp
    11b1:       e8 0c 00 00 00          call   11c2 <_Z11print_hellov>
    11b6:       e8 9a 00 00 00          call   1255 <_Z9print_byev>
    11bb:       b8 00 00 00 00          mov    $0x0,%eax
    11c0:       5d                      pop    %rbp
    11c1:       c3                      ret    

00000000000011c2 <_Z11print_hellov>:
    11c2:       f3 0f 1e fa             endbr64 
    11c6:       55                      push   %rbp
    11c7:       48 89 e5                mov    %rsp,%rbp
    11ca:       48 8d 05 33 0e 00 00    lea    0xe33(%rip),%rax        # 2004 <_IO_stdin_used+0x4>
    11d1:       48 89 c6                mov    %rax,%rsi
    11d4:       48 8d 05 65 2e 00 00    lea    0x2e65(%rip),%rax        # 4040 <_ZSt4cout@GLIBCXX_3.4>
    11db:       48 89 c7                mov    %rax,%rdi
    11de:       e8 ad fe ff ff          call   1090 <_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc@plt>

....

0000000000001255 <_Z9print_byev>:
    1255:       f3 0f 1e fa             endbr64 
    1259:       55                      push   %rbp
    125a:       48 89 e5                mov    %rsp,%rbp
    125d:       48 8d 05 af 0d 00 00    lea    0xdaf(%rip),%rax        # 2013 <_IO_stdin_used+0x13>
    1264:       48 89 c6                mov    %rax,%rsi
    1267:       48 8d 05 d2 2d 00 00    lea    0x2dd2(%rip),%rax        # 4040 <_ZSt4cout@GLIBCXX_3.4>
    126e:       48 89 c7                mov    %rax,%rdi
    1271:       e8 1a fe ff ff          call   1090 <_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc@plt>
    1276:       48 8b 15 53 2d 00 00    mov    0x2d53(%rip),%rdx        # 3fd0 <_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostr


Как мы видим, все наши функции оказались в бинарнике.
Это и есть статическая библиотку, все функции оказываются внутри.
Плюсы такого подхода - невозможно использовать подмены библиотек, один файл, 
что проще распространять и так далее. Минусы - огромный вес файла-результата. 
Поэтому существуют динамические библиотеки.

// ========================

Динамические библиотеки.

Глобальное отличие от статических - динамические библиотеки не оказываются внутри
бинариника, а лежат где то в системе, но при запуске программы оказываются в
памяти программы благодаря механизму отображения файлов.

То есть фактически у нас одина файл на диске, к которому все и обращаются. Отсюда и
название в Linux/UNIX Shared Object (*.so).

Все что нам нужно это пересобрать уже приведенный выше код следующим образом
-fPIC это флаг компилятора Position Independent Code, трубуется чтобы 
код работал одинакого в рахных участках памяти.  (???)

$ g++ -c -fPIC bye.cpp hello.cpp

После этого мы получаем два объектных файла, которые могут быть собраны в *.so.

$ g++ -shared -o libprint.so bye.o hello.o

таким образом мы получаем динамическую библиотеку libprint.so, которая самая 
использует динамическую библиотеку iostream.

Собираем бинарник и пытаемся запустить 

$ g++ main.cpp -L. -lprint -o main ( -L{путь_до_библиотеки} -l{имя_библиотеки})

$ ./main 
./main: error while loading shared libraries: libprint.so: cannot open shared object file: No such file or directory

Суть в том, что система ищет динамические библиотеку по заранее указанному адресу, 
а наша библиотку лежит рядом с бинарником, поэтому система не может ее найти.
Чтобы добавить сврй кастомный путь для поиска дин библиотеку, необходимо использовать
LD_LIBRARY_PATH, в ней нужно указать директорию с динамич библиотекой.

LD_LIBRARY_PATH=. ./main



